---
title: "명세서가 새로운 소스 코드다"
originalTitle: "Specs Are the New Source Code"
author: "Ravi Mehta, Danny Martinez"
sourceUrl: "https://blog.ravi-mehta.com/p/specs-are-the-new-source-code"
translatedAt: "2026-01-13"
status: "final"
qaScore:
  consistency: 9
  readability: 8
  accuracy: 9
  overall: 8
---

# 명세서의 죽음이여, 명세서 만세!

[원본 링크](https://blog.ravi-mehta.com/p/specs-are-the-new-source-code)

제 커리어 동안 명세서는 점점 더 짧아지고 또 짧아졌습니다. Microsoft에서 일을 시작했을 때 PM의 가치는 명세서 무게로 측정했습니다. 몇 년 후 Tripadvisor에서는 냅킨에 휘갈겨 쓴 명세서를 들고 제품 리뷰에 참석한 PM이 전설이 되었습니다.

제품 팀은 명세서를 서류 작업처럼 취급합니다—"진짜 일"인 제품 출시 전에 어쩔 수 없이 거쳐야 하는 필수 악이라고요. 엔지니어는 우아한 코드로, 디자이너는 아름다운 UX로 칭찬받습니다. PM은 임팩트 전달로 인정받습니다. 하지만 명세서는? 급하게 작성하고, 던져두고, 잊어버립니다.

이것은 언제나 실수였습니다. 제 Product Competency Toolkit에서 기능 명세서(Feature Specification)가 맨 위에 있습니다—12가지 역량 중 첫 번째입니다—이유가 있습니다. 이것은 제품 전달(Product Delivery) 및 제품 품질(Product Quality)과 함께 제품 실행력(Product Execution)을 뒷받침합니다.

완벽한 실행력은 좋은 프로덕트 매니지먼트의 기반이며, 훌륭한 명세서가 그 출발선입니다.

오늘날 우리가 만드는 방식이 변하고 있습니다. 엔지니어는 점점 빨라집니다—훨씬 더요. AI는 대략적인 아이디어를 몇 분 만에 작동하는 코드로 바꿉니다. 병목은 더 이상 만드는 것이 아닙니다. **무엇을 만들어야 하는지 아는 것, 그리고 팀을 그 요구사항에 정렬시키는 것**입니다.

갑자기 하찮게 여기던 명세서가 더 이상 일시적인 서류 작업이 아닙니다. 프로덕트 매니지먼트의 기반입니다—명세서 자체가 소스 코드가 되고 있습니다.

## PM이 갑자기 병목이 된 이유

앤드류 응(Andrew Ng)은 최근 강연 "Building Faster with AI"에서 전례 없는 트렌드를 언급했습니다:

"제 인생에서 처음으로 매니저들이 엔지니어 두 배의 PM을 두자고 제안하는 것을 봤습니다. 이 제안이 좋은 생각인지 아직 모르겠지만, 세상이 어디로 가는지 보여주는 신호라고 생각합니다." —앤드류 응

이전 포스트의 예측을 확인해줍니다: 엔지니어가 AI로 몇 배나 빠르게 전달하면서, 기업은 **생산적인 엔지니어를 지원하기 위해 PM이 더 많이 필요합니다. 더 적게가 아니라요**.

제품 전달이 가속화되면서 프로덕트 매니지먼트의 다른 모든 측면에 강렬한 압력이 가해집니다—고객 니즈 이해, 적절한 기능 설계, 임팩트 검증.

그리고 그 모든 압력이 하나의 산출물에 집중됩니다—명세서입니다.

## 명세서—새로운 소스 코드

전통적인 소프트웨어 개발에서 프로그래머는 사람이 읽을 수 있는 "소스 코드"를 작성하고, 이것이 고도로 최적화된 기계 읽기용 "오브젝트 코드"로 컴파일됩니다. "오브젝트 코드"(바이너리라고도 함)는 소스 코드로 다시 만들 수 있는 부산물입니다. 소스 코드가 **문자 그대로** 진실의 원천(source of truth)입니다.

OpenAI의 션 그로브(Sean Grove)는 도발적인 논제를 가지고 있습니다. 최근 강연 "The New Code"에서 잘 작성된 프롬프트(즉, 명세서)가 새로운 소스 코드라고 주장합니다.

그 관점에서 보면, 우리는 AI 개발을 거꾸로 하고 있습니다. 모델에 의도를 전달하기 위해 신중하게 프롬프트를 작성합니다. AI가 코드를 생성합니다. 그런 다음 코드는 보존하고 프롬프트는 버립니다.

그로브는 이렇게 관찰합니다: "이것은 마치 소스를 파쇄하고 바이너리를 아주 신중하게 버전 관리하는 것과 같습니다."

생각해 보세요. 전통적인 프로그래밍에서 소스 코드는 신성합니다. 소스에는 주석, 구조, 문서화—시스템을 이해하고 수정하는 데 필요한 모든 것이 담겨 있습니다. 바이너리는 그저 하위 산출물일 뿐입니다.

하지만 AI에서는 이 관계가 뒤집어졌습니다. 생성된 코드를 보존할 가치가 있는 산출물로, 명세서—프롬프트—는 일회용으로 취급합니다.

그로브는 이것이 정확히 거꾸로라고 주장합니다. 코드는, 심지어 우아한 코드도, 명세서의 "손실 투영(lossy projection)"입니다. 바이너리를 디컴파일해도 원래 주석과 변수 이름을 얻을 수 없듯이, 코드를 읽어도 그 뒤의 완전한 의도를 알 수 없습니다.

그러나 명세서에는 모든 것이 담겨 있습니다. 충분히 견고한 명세서 하나면 "좋은 TypeScript, 좋은 Rust, 서버, 클라이언트, 문서화, 튜토리얼, 블로그 포스트, 심지어 팟캐스트까지" 생성할 수 있습니다.

"충분히 견고한 명세서 하나면 좋은 TypeScript, 좋은 Rust, 서버, 클라이언트, 문서화, 튜토리얼, 블로그 포스트, 심지어 팟캐스트까지 생성할 수 있습니다." —션 그로브, OpenAI

더 중요한 점은, 명세서가 코드가 할 수 없는 일을 한다는 것입니다: 사람과 기계 모두를 공유된 목표에 정렬시킵니다. 그로브는 간단히 표현합니다: "문서화된 명세서는 사람들을 효과적으로 정렬시키며, 소통하고 토론하고 참조하고 동기화하는 데 사용하는 산출물입니다."

그는 예측합니다: "가까운 미래에, 가장 효과적으로 소통하는 사람이 가장 가치 있는 프로그래머가 될 것입니다. 문자 그대로, 효과적으로 소통할 수 있다면 프로그래밍할 수 있습니다."

새로운 희소 스킬은 코딩이 아닙니다. 의도와 가치를 완전히 담아낸 명세서를 작성하는 것입니다.

프로덕트 매니저에게 이것은 익숙하게 들릴 것입니다. 우리가 항상 해온 일입니다—다만 이제 기계도 함께 듣고 있을 뿐입니다.

## 잠깐, 프로토타입이 명세서를 죽이지 않았나요?

최근까지 제품 수명주기는 명세서(또는 PRD, 컨셉 문서, 냅킨)로 시작해서 초기 와이어프레이밍, 디자인, 프로토타이핑, MVP 개발을 진행했습니다.

전통적인 접근법은 필요악처럼 느껴졌습니다. 엔지니어는 고객 손에 무언가를—아무거나—쥐여주기 위해 기본적인 MVP를 만들었습니다. "제품 첫 버전이 부끄럽지 않다면 너무 늦게 출시한 것이다"가 복음이 되었습니다.

제품을 만드는 전체 접근법이 최근 크게 변했고, 이 새로운 세상에서 **명세서는 종종 입력이 아니라 출력입니다**.

오늘날 고객 손에 프로토타입을 쥐여주기 위해 코드 한 줄도 출시할 필요가 없습니다. v0, Lovable, Replit 같은 도구들은 몇 주가 아닌 몇 시간 만에 작동하는 프로토타입을 만들게 해줍니다. 엔지니어링 없이요.

이것은 단순히 더 빠른 게 아닙니다—근본적으로 다릅니다. "바이브 코딩"된 프로토타입이 있으면, 기능 명세서 한 줄 쓰기 전에 실제 고객 피드백을 수집할 수 있습니다. 가정을 테스트하고, 플로우를 반복하고, 인터랙션을 다듬을 수 있습니다.

**기존 워크플로우**: 모호한 아이디어 → 와이어프레임 → 디자인 → 엔지니어가 만든 MVP → 고객 피드백 → 고통스러운 명세서 수정 → 와이어프레임 → 디자인 → 다시 구현 → 기도.

**새로운 워크플로우**: 모호한 아이디어 → 빠른 프로토타입 → 고객 피드백 → 명확한 명세서 → AI 지원 구현.

프로토타입이 명세서를 죽인 게 아닙니다. 프로토타입이 명세서를 더 좋게 만들고 있습니다.

## 명세서 주도 개발 실전

이 모든 것이 실제로 어떻게 펼쳐지는지 실습 예시를 살펴봅시다. 대니 마르티네즈(Danny Martinez)는 decimals의 창업자로, 크리에이터 이코노미의 전문가들이 자신의 네트워크에서 인재를 채용 기회에 연결하는 플랫폼(스텔스 모드)입니다.

대니가 명세서 주도 개발 프로세스를 안내해 줄 것입니다—두 가지 임팩트를 가져온 프로세스입니다:

1. 큰 기능에서 엔지니어링과의 커뮤니케이션이 대폭 개선되었습니다.
2. 대니가 사전 코딩 경험 없이도 작은 것들은 상세한 명세서에서 라이브 기능까지 직접 갈 수 있게 되었습니다.

대니에게 넘기겠습니다...

여기 제가 최근 작업한 예시가 있습니다. 맥락을 말씀드리면, 우리는 전문가 인플루언서들이 자신의 네트워크에서 후보자를 채용 기회에 연결하는 제품을 만들고 있습니다. 새 랜딩 페이지를 출시한 후, 전문가들에게 자신의 페이지 링크에 빠르게 접근할 방법을 제공해야 했습니다.

> 헤더에 company-apply 페이지로 이동하는 버튼이 필요해요. 저는 지금 이메일에 집중하고 있어서요. 이건 바이브 코딩으로 할 수 있으니까 맡아줄 수 있으면 부탁해요.

제 공동 창업자가 보낸 메시지로, 출시해야 할 간단한 버튼에 대한 것이었습니다. 쉬운 일이고, 비기술자가 이제 직접 출시할 수 있는 정확히 그런 종류의 것입니다.

몇 분 만에 출시한 설정과 단계는 다음과 같습니다:

- **프로젝트 관리 도구**: Linear
- **IDE**: VS Code
- **확장 프로그램**: GitHub Copilot Pro
- **모델**: Claude Sonnet 4
- **MCP 서버**: Linear MCP server - Copilot을 통해 Linear 티켓 접근

프로세스 단계를 살펴봅시다(위 Loom 영상을 따라가세요):

1. 공동 창업자의 Slack 메시지에서 Linear 티켓 생성 (00:14)
2. 위 티켓에서 원하는 카피 명확히 하기 (00:25)
3. Copilot을 열고 Claude에게 Linear 티켓을 열도록 프롬프트 (01:18)
4. Claude에게 티켓을 검토하고 코드베이스와 대조해서 분석하도록 프롬프트 (01:52)
5. Claude에게 브랜치를 만들고 변경사항을 구현하도록 프롬프트 (02:30)
6. 변경사항이 예상대로 작동하는지 테스트 (02:52)
7. GitHub에서 PR을 열어 코드베이스에 변경사항 출시 (03:55)
8. 엔지니어가 PR을 리뷰/승인할 때까지 대기

전체적으로 보면, 이 설정의 진정한 힘이 드러납니다. 네, 사소한 예시지만, 요점은 남아 있습니다: 비기술자가 이제 Linear 티켓, 코드베이스, 엔지니어 사이를 GitHub Copilot을 통한 Claude 프롬프트 몇 개로 오갈 수 있습니다.

다시 말하지만, 이 모든 것의 핵심은 코드 자체가 아닙니다: 명세서입니다.

위 내용이 잘 작동하려면 필요한 것들을 주의해서 말씀드립니다:

1. **구체적으로 작성하기**: 모호한 명세서는 지저분한 코드베이스만 만듭니다. Claude로 티켓 초기 초안을 검토하고, 코드베이스를 리뷰하고, 더 구체적으로 만드는 것이 프로세스의 필수입니다. 우리는 좋은 명세서 작성 가이드라인도 있습니다.

2. **선별적으로 하기**: 위 방법은 단순한 작업에 사용하는 게 이상적입니다. 티켓이 복잡할수록 뭘 하는지 아는 사람이 개입해야 합니다(이런 경우 "셀프 서비스"는 전혀 셀프 서비스가 아닙니다).

3. **게이트키핑**: 이 접근법이 잘 작동하는 이유는 뭘 하는지 아는 엔지니어가 변경사항을 리뷰하고 단순함과 기능성 사이의 균형을 유지하기 때문입니다.

분명히 합시다: 규칙이 바뀌었습니다. 명세서는 LLM을 포함해 제품을 만드는 모든 사람의 진실의 원천(source of truth)입니다.

적절한 설정이 있으면, 비기술자로서 코드베이스에 기여하는 것을 현실적으로 기대할 수 있습니다. 충분한 시간과 인내심이 있으면, 코드베이스를 이해하기 시작하고 매번 Claude에 의존하는 대신 직접 변경사항을 구현할 수 있습니다.

언젠가는 AI 에이전트가 당신이 커피 마시는 동안 티켓을 출시하는 것을 기대할 수도 있을 것입니다.

PM이고 AI가 직업에 미칠 영향이 걱정된다면, 핵심은 직업 자체가 변하고 있다는 것을 인식하는 것입니다. 하지만 다른 모든 사람에게도 마찬가지입니다. 좋은 점은 훌륭한 PM에게 필요한 핵심 스킬이 이 새로운 세상에서 더욱 가치 있어졌다는 것입니다.

이전 포스트에서 예측했듯이, 이런 방식으로 일하는 회사들은 PM이 더 많이 필요합니다. 더 적게가 아니라요. 그 예측이 꽤 잘 맞아가고 있습니다.

## 명세서 만세!

'사이버스페이스'라는 표현을 만든 SF 작가 윌리엄 깁슨(William Gibson)은 이렇게 말했습니다:

> 미래는 이미 여기에 있다—다만 고르게 분포되어 있지 않을 뿐이다.

AI로 가능한 것과 가능하지 않은 것을 생각할 때 이 말이 떠오릅니다. 오늘날 AI의 이득은 심하게 불균등합니다. 코드, 텍스트, 이미지 생성 같은 것들은 양자 도약을 이루었습니다. **AI 속도**로 작동합니다. 고객과 대화하기, 니즈 발견하기, 구매 설득하기 같은 것들은 여전히 **인간 속도**로 움직입니다.

이 불균등한 분포가 제품 팀을 재편하고 있습니다. 스포트라이트가 구현 작업에서 이해 작업으로 이동하고 있습니다. 최고의 PM을 차별화해 온 핵심 스킬—사용자 니즈 이해, 문제의 명확한 정의, 우아한 솔루션 설계—이 기하급수적으로 가치가 높아졌습니다.

최고의 PM은 그 인사이트를 명세서로 변환합니다—팀을 정렬시키고, 구현을 가이드하고, 점점 자동화되는 개발 세계에서 지속적인 산출물로 남는 명세서로요.

---

## 핵심 요약

- 명세서는 일시적인 서류 작업에서 프로덕트 매니지먼트의 기반으로 진화함
- AI가 엔지니어를 가속화하면서 기업은 PM이 더 적게가 아니라 더 많이 필요
- 션 그로브: 명세서가 새로운 소스 코드이고, 코드는 명세서의 "손실 투영"
- v0, Lovable, Replit 같은 도구들이 "프로토타입 먼저, 명세서 나중" 워크플로우를 가능하게 함
- 비기술자도 잘 작성된 명세서와 AI 도구로 코드베이스에 기여 가능
- 가장 효과적으로 소통하는 사람이 가장 가치 있는 프로그래머가 될 것
