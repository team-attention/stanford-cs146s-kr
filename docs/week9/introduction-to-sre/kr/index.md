---
title: "1장 - 소개"
originalTitle: "Chapter 1 - Introduction"
author: "Benjamin Treynor Sloss"
editor: "Betsy Beyer"
sourceUrl: "https://sre.google/sre-book/introduction/"
translatedAt: "2026-01-13"
status: "final"
qaScore:
  consistency: 9
  readability: 8
  accuracy: 9
  overall: 9
---

# 소개

*Benjamin Treynor Sloss[^1] 저*
*Betsy Beyer 편집*

> 희망은 전략이 아니다.
>
> — 전통적인 SRE 격언

시스템이 스스로 돌아가지 않는다는 것은 누구나 인정하는 진리다. 그렇다면 시스템, 특히 대규모로 운영되는 복잡한 컴퓨팅 시스템은 어떻게 운영해야 할까?

## 서비스 관리에 대한 시스템 관리자 접근 방식

역사적으로 기업들은 복잡한 컴퓨팅 시스템을 운영하기 위해 시스템 관리자를 고용해왔다.

시스템 관리자, 즉 sysadmin 접근 방식은 기존 소프트웨어 컴포넌트를 조합하고 이들이 함께 동작하도록 배포해서 서비스를 만드는 것이다. 시스템 관리자는 서비스를 운영하고 발생하는 이벤트와 업데이트에 대응한다. 시스템의 복잡성과 트래픽 양이 증가하면 이벤트와 업데이트도 비례해서 늘어나고, 시스템 관리자 팀도 추가 작업을 수용하기 위해 확장된다. 시스템 관리자 역할은 제품 개발자에게 요구되는 기술과 현저히 다르기 때문에, 개발자와 시스템 관리자는 별개의 팀으로 나뉜다: "개발"과 "운영" 또는 "ops".

서비스 관리의 시스템 관리자 모델은 여러 장점이 있다. 서비스 운영과 인력 배치를 결정하는 회사 입장에서 이 접근 방식은 구현하기 비교적 쉽다: 익숙한 업계 패러다임으로서 배우고 모방할 사례가 많다. 관련 인재 풀도 이미 널리 형성되어 있다. 조립된 시스템을 운영하는 데 도움이 되는 기존 도구, 소프트웨어 컴포넌트(기성품이든 아니든), 통합 회사들이 있으므로, 초보 시스템 관리자 팀이 바퀴를 재발명하고 처음부터 시스템을 설계할 필요가 없다.

시스템 관리자 접근 방식과 그에 수반되는 개발/운영 분리에는 여러 단점과 함정이 있다. 크게 두 가지 범주로 나뉜다: 직접 비용과 간접 비용.

직접 비용은 미묘하거나 애매하지 않다. 변경 관리와 이벤트 처리 모두에 수동 개입이 필요한 팀으로 서비스를 운영하면, 서비스나 트래픽이 증가함에 따라 비용이 커진다. 팀 규모가 시스템이 생성하는 부하에 비례해서 반드시 확장되어야 하기 때문이다.

개발/운영 분리의 간접 비용은 미묘할 수 있지만, 종종 직접 비용보다 조직에 더 큰 부담이 된다. 이러한 비용은 두 팀의 배경, 기술, 인센티브가 상당히 다르다는 사실에서 발생한다. 두 팀은 상황을 설명하는 데 다른 용어를 사용한다. 위험과 기술적 해결책의 가능성에 대해 다른 가정을 가지고 있다. 제품 안정성의 목표 수준에 대해서도 다른 가정을 가진다. 그룹 간의 분리는 인센티브뿐만 아니라 의사소통, 목표, 그리고 결국에는 신뢰와 존중의 분리로 쉽게 발전할 수 있다. 이 결과는 병폐다.

따라서 전통적인 운영 팀과 제품 개발 팀은 종종 갈등을 겪게 되며, 가장 눈에 띄는 것은 소프트웨어를 얼마나 빨리 프로덕션에 릴리스할 수 있느냐다. 본질적으로, 개발 팀은 새로운 기능을 출시하고 사용자가 채택하는 것을 보고 싶어한다. *그들*의 본질에서, 운영 팀은 페이저를 들고 있는 동안 서비스가 중단되지 않기를 원한다. 대부분의 장애는 어떤 종류의 변경으로 인해 발생하기 때문에—새로운 설정, 새로운 기능 출시, 또는 새로운 유형의 사용자 트래픽—두 팀의 목표는 근본적으로 긴장 관계에 있다.

양쪽 그룹 모두 자신들의 이익을 가장 노골적으로 표현하는 것은 용납되지 않는다는 것을 안다("우리는 언제든지 아무 방해 없이 무엇이든 출시하고 싶다" 대 "일단 작동하면 시스템에서 아무것도 변경하고 싶지 않다"). 그리고 용어와 위험 가정이 다르기 때문에, 양쪽 그룹은 종종 자신들의 이익을 증진하기 위해 익숙한 형태의 참호전에 의존한다. 운영 팀은 출시 및 변경 게이트를 도입해서 실행 중인 시스템을 변경의 위험으로부터 보호하려 한다. 예를 들어, 출시 검토에는 과거에 장애를 일으킨 *모든* 문제에 대한 명시적 확인이 포함될 수 있다—이는 임의로 긴 목록이 될 수 있으며, 모든 요소가 동일한 가치를 제공하지는 않는다. 개발 팀은 대응하는 방법을 빠르게 배운다. "출시"를 줄이고 더 많은 "플래그 전환", "점진적 업데이트", 또는 "체리픽"을 한다. 제품을 샤딩해서 더 적은 기능이 출시 검토 대상이 되도록 하는 전술을 채택한다.

## 구글의 서비스 관리 접근 방식: Site Reliability Engineering

갈등이 소프트웨어 서비스를 제공하는 데 있어 필연적인 부분은 아니다. 구글은 다른 접근 방식으로 시스템을 운영하기로 선택했다: Site Reliability Engineering 팀은 제품을 운영하고 시스템 관리자가 수동으로 수행하던 작업을 자동화하는 시스템을 만들기 위해 소프트웨어 엔지니어를 고용한다.

구글에서 정의한 Site Reliability Engineering이란 정확히 무엇인가? 내 설명은 간단하다: SRE는 소프트웨어 엔지니어에게 운영 팀을 설계해달라고 요청하면 일어나는 일이다. 2003년에 구글에 입사해서 7명의 엔지니어로 구성된 "프로덕션 팀"을 운영하라는 임무를 받았을 때, 그 시점까지 내 인생 전체는 소프트웨어 엔지니어링이었다. 그래서 SRE로 일한다면 *내*가 원하는 방식으로 그룹을 설계하고 관리했다. 그 그룹은 이후 구글의 현재 SRE 팀으로 성장했으며, 평생 소프트웨어 엔지니어가 구상한 그 기원에 여전히 충실하다.

구글 서비스 관리 접근 방식의 주요 구성 요소는 각 SRE 팀의 구성이다. 전체적으로, SRE는 두 가지 주요 범주로 나눌 수 있다.

50-60%는 구글 소프트웨어 엔지니어, 더 정확히 말하면 구글 소프트웨어 엔지니어를 위한 표준 절차로 고용된 사람들이다. 나머지 40-50%는 구글 소프트웨어 엔지니어링 자격에 매우 근접했지만(즉, 필요한 기술의 85-99%), *추가로* SRE에 유용하지만 대부분의 소프트웨어 엔지니어에게는 드문 기술을 가진 후보자들이다. UNIX 시스템 내부와 네트워킹(레이어 1에서 레이어 3) 전문 지식이 우리가 찾는 가장 일반적인 두 가지 대안적 기술 유형이다.

모든 SRE에게 공통적인 것은 복잡한 문제를 해결하기 위한 소프트웨어 시스템을 개발하는 것에 대한 믿음과 적성이다. SRE 내에서 우리는 두 그룹의 경력 발전을 밀접하게 추적하며, 현재까지 두 트랙의 엔지니어 간에 실제 성과 차이를 발견하지 못했다. 사실, SRE 팀의 다소 다양한 배경은 종종 여러 기술의 융합의 산물임이 분명한 영리하고 고품질의 시스템을 만들어낸다.

SRE 채용에 대한 우리의 접근 방식 결과, (a) 수동으로 작업을 수행하는 것에 빠르게 지루해하고, (b) 솔루션이 복잡하더라도 이전의 수동 작업을 대체하는 소프트웨어를 작성할 수 있는 기술을 가진 팀을 얻게 된다. SRE는 또한 개발 조직의 나머지 부분과 학문적, 지적 배경을 공유한다. 따라서 SRE는 근본적으로 역사적으로 운영 팀이 수행해온 작업을 수행하지만, 소프트웨어 전문성을 가진 엔지니어를 사용하고, 이러한 엔지니어들이 본질적으로 인간 노동을 대체하기 위해 소프트웨어로 자동화를 설계하고 구현하는 성향과 능력을 가지고 있다는 사실에 기댄다.

설계상, SRE 팀이 엔지니어링에 집중하는 것이 매우 중요하다. 지속적인 엔지니어링 없이는 운영 부하가 증가하고 팀은 워크로드를 따라가기 위해 더 많은 사람이 필요하게 된다. 결국, 전통적인 운영 중심 그룹은 서비스 규모에 선형적으로 확장된다: 서비스가 지원하는 제품이 성공하면, 운영 부하는 트래픽과 함께 증가한다. 이는 같은 작업을 반복해서 수행하기 위해 더 많은 사람을 고용한다는 것을 의미한다.

이 운명을 피하려면, 서비스를 관리하는 팀은 코드를 작성해야 한다. 그렇지 않으면 익사하게 된다. 따라서 구글은 *모든 SRE의 총 "운영" 작업에 50% 상한을 둔다*—티켓, 온콜, 수동 작업 등. 이 상한은 SRE 팀이 서비스를 안정적이고 운영 가능하게 만들기에 충분한 시간을 확보하게 한다. 이 상한은 상한선이다; 시간이 지남에 따라, 자체적으로 두면, SRE 팀은 매우 적은 운영 부하를 가지고 거의 전적으로 개발 작업에 참여하게 되어야 한다. 서비스가 기본적으로 스스로 실행되고 복구되기 때문이다: 우리는 단지 *자동화된* 시스템이 아니라 *자동* 시스템을 원한다. 실제로는 규모와 새로운 기능이 SRE를 긴장하게 한다.

구글의 경험 법칙은 SRE 팀이 나머지 50%의 시간을 실제로 개발 작업에 사용해야 한다는 것이다. 그렇다면 그 임계값을 어떻게 강제할까? 우선, SRE 시간이 어떻게 사용되는지 측정해야 한다. 그 측정을 통해, 개발 작업에 50% 미만의 시간을 지속적으로 사용하는 팀이 관행을 변경하도록 보장한다. 종종 이는 운영 부담의 일부를 개발 팀에 다시 전가하거나, 추가 운영 책임 없이 팀에 인력을 추가하는 것을 의미한다. 운영과 개발 작업 사이의 이 균형을 의식적으로 유지함으로써 SRE가 창의적이고 자율적인 엔지니어링에 참여할 대역폭을 확보하면서도 서비스 운영 측면에서 얻은 지혜를 유지할 수 있다.

구글 SRE의 대규모 시스템 운영 접근 방식이 많은 장점을 가지고 있음을 발견했다. SRE가 구글 시스템이 스스로 실행되도록 코드를 직접 수정하기 때문에, SRE 팀은 빠른 혁신과 변화에 대한 높은 수용으로 특징지어진다. 이러한 팀은 비교적 저렴하다—동일한 서비스를 운영 중심 팀으로 지원하려면 훨씬 더 많은 인원이 필요할 것이다. 대신, 시스템을 실행, 유지, 개선하는 데 필요한 SRE 수는 시스템 규모에 비해 차선형으로 확장된다. 마지막으로, SRE는 개발/운영 분리의 역기능을 우회할 뿐만 아니라, 이 구조는 제품 개발 팀도 개선한다: 제품 개발과 SRE 팀 간의 쉬운 이동이 전체 그룹을 교차 훈련시키고, 그렇지 않으면 백만 코어 분산 시스템을 구축하는 방법을 배우기 어려울 수 있는 개발자의 기술을 향상시킨다.

이러한 순이익에도 불구하고, SRE 모델은 고유한 도전 과제가 있다. 구글이 지속적으로 직면하는 한 가지 도전은 SRE 채용이다: SRE는 제품 개발 채용 파이프라인과 동일한 후보자를 놓고 경쟁할 뿐만 아니라, 코딩과 시스템 엔지니어링 기술 모두에서 채용 기준을 매우 높게 설정한다는 사실은 채용 풀이 필연적으로 작다는 것을 의미한다. 우리 분야가 비교적 새롭고 독특하기 때문에, SRE 팀을 구축하고 관리하는 방법에 대한 업계 정보가 많지 않다(이 책이 그 방향으로 진전을 이루기를 바란다!). 그리고 SRE 팀이 구성되면, 서비스 관리에 대한 그들의 잠재적으로 비정통적인 접근 방식은 강력한 경영진 지원이 필요하다. 예를 들어, 에러 버짓이 소진되면 분기의 나머지 기간 동안 릴리스를 중단하기로 한 결정은 경영진이 강제하지 않는 한 제품 개발 팀이 수용하지 않을 수 있다.

### DevOps인가 SRE인가?

"DevOps"라는 용어는 2008년 말 업계에 등장했으며, 이 글을 쓰는 시점(2016년 초)에도 여전히 유동적인 상태다. 핵심 원칙—시스템 설계 및 개발의 각 단계에서 IT 기능 참여, 인간 노력 대비 자동화에 대한 높은 의존, 운영 작업에 대한 엔지니어링 관행 및 도구 적용—은 SRE의 많은 원칙 및 관행과 일치한다. DevOps를 더 넓은 범위의 조직, 관리 구조, 인력에 대한 여러 핵심 SRE 원칙의 일반화로 볼 수 있다. 마찬가지로 SRE를 일부 특이한 확장을 가진 DevOps의 특정 구현으로 볼 수도 있다.

## SRE의 원칙

워크플로우, 우선순위, 일상 운영의 뉘앙스는 SRE 팀마다 다르지만, 모두 지원하는 서비스에 대한 기본 책임 세트를 공유하고 동일한 핵심 원칙을 준수한다. 일반적으로, SRE 팀은 서비스의 *가용성, 레이턴시, 성능, 효율성, 변경 관리, 모니터링, 긴급 대응, 용량 계획*에 대한 책임이 있다. 우리는 SRE 팀이 환경과 상호작용하는 방법에 대한 규칙과 원칙을 성문화했다—프로덕션 환경뿐만 아니라 제품 개발 팀, 테스트 팀, 사용자 등과의 상호작용도 포함한다. 이러한 규칙과 업무 관행은 운영 작업이 아닌 엔지니어링 작업에 집중하도록 돕는다.

다음 섹션에서는 구글 SRE의 각 핵심 원칙을 논의한다.

### 엔지니어링에 대한 지속적인 집중 보장

이미 논의했듯이, 구글은 SRE의 운영 작업을 시간의 50%로 상한을 둔다. 나머지 시간은 프로젝트 작업에 코딩 기술을 사용해야 한다. 실제로 이는 SRE가 수행하는 운영 작업의 양을 모니터링하고, 초과 운영 작업을 제품 개발 팀으로 리디렉션해서 달성한다: 버그와 티켓을 개발 관리자에게 재할당하고, 개발자를 온콜 페이저 순환에 (재)통합하는 등. 운영 부하가 50% 이하로 떨어지면 리디렉션이 종료된다. 이는 또한 수동 개입이 필요 없는 시스템을 구축하도록 개발자를 안내하는 효과적인 피드백 메커니즘 역할을 한다. 이 접근 방식은 SRE와 개발 모두 전체 조직이 안전 밸브 메커니즘이 존재하는 이유를 이해하고, 제품이 필요할 만큼 충분한 운영 부하를 생성하지 않아 오버플로우 이벤트가 없도록 하는 목표를 지원할 때 잘 작동한다.

운영 작업에 집중할 때, 평균적으로 SRE는 8-12시간 온콜 교대당 최대 2개의 이벤트를 받아야 한다. 이 목표 볼륨은 온콜 엔지니어에게 이벤트를 정확하고 빠르게 처리하고, 정리하고 정상 서비스를 복원한 다음, 포스트모템을 수행할 충분한 시간을 준다. 온콜 교대당 정기적으로 2개 이상의 이벤트가 발생하면, 문제를 철저히 조사할 수 없고 엔지니어들은 이러한 이벤트에서 배우지 못할 정도로 압도된다. 페이저 피로 시나리오도 규모와 함께 개선되지 않는다. 반대로, 온콜 SRE가 교대당 지속적으로 1개 미만의 이벤트를 받으면, 그들을 대기시키는 것은 시간 낭비다.

포스트모템은 페이지가 발생했는지 여부와 관계없이 모든 중요한 인시던트에 대해 작성해야 한다; 페이지를 트리거하지 않은 포스트모템이 더 가치 있다, 명확한 모니터링 갭을 가리킬 가능성이 높기 때문이다. 이 조사는 무슨 일이 일어났는지 상세히 확인하고, 이벤트의 모든 근본 원인을 찾고, 문제를 수정하거나 다음에 더 잘 대응하기 위한 조치를 할당해야 한다. 구글은 *비난 없는 포스트모템 문화* 하에서 운영되며, 결함을 피하거나 최소화하는 것이 아니라 결함을 노출하고 이를 수정하기 위해 엔지니어링을 적용하는 것을 목표로 한다.

### 서비스의 SLO를 위반하지 않으면서 최대 변경 속도 추구

제품 개발과 SRE 팀은 각자의 목표에 있는 구조적 갈등을 제거함으로써 생산적인 협력 관계를 누릴 수 있다. 구조적 갈등은 혁신 속도와 제품 안정성 사이에 있으며, 앞서 설명했듯이 이 갈등은 종종 간접적으로 표현된다. SRE에서 우리는 이 갈등을 전면에 내세운 다음, *에러 버짓*을 도입해서 해결한다.

에러 버짓은 *기본적으로 모든 것에 대해 100%는 잘못된 신뢰성 목표라는* 관찰에서 비롯된다(심장 박동기와 안티록 브레이크는 주목할 만한 예외다). 일반적으로, 어떤 소프트웨어 서비스나 시스템에서든, 사용자가 100% 가용성과 99.999% 가용성 시스템을 구별할 수 없기 때문에 100%는 올바른 신뢰성 목표가 아니다. 사용자와 서비스 사이의 경로에는 다른 많은 시스템이 있고(노트북, 가정용 WiFi, ISP, 전력망...) 이러한 시스템들은 총체적으로 99.999%보다 훨씬 낮은 가용성을 가진다. 따라서 99.999%와 100% 사이의 한계 차이는 다른 불가용성의 노이즈에 묻히고, 사용자는 마지막 0.001%의 가용성을 추가하는 데 필요한 엄청난 노력으로부터 아무런 이점을 받지 못한다.

시스템에 대해 100%가 잘못된 신뢰성 목표라면, 시스템에 대한 올바른 신뢰성 목표는 무엇인가? 이것은 실제로 기술적인 질문이 전혀 아니다—다음 고려 사항을 따져봐야 하는 제품 질문이다:

- 사용자가 제품을 사용하는 방식을 고려할 때, 어떤 수준의 가용성에 만족할 것인가?
- 제품의 가용성에 불만족한 사용자에게 어떤 대안이 있는가?
- 다른 가용성 수준에서 사용자의 제품 사용에 어떤 일이 일어나는가?

비즈니스 또는 제품이 시스템의 가용성 목표를 설정해야 한다. 그 목표가 설정되면, 에러 버짓은 1에서 가용성 목표를 뺀 것이다. 99.99% 가용성인 서비스는 0.01% 불가용이다. 그 허용된 0.01% 불가용성이 서비스의 *에러 버짓*이다. 초과 지출만 하지 않으면 버짓을 원하는 대로 사용할 수 있다.

그렇다면 에러 버짓을 어떻게 사용하고 싶은가? 개발 팀은 기능을 출시하고 새로운 사용자를 유치하고 싶어한다. 이상적으로, 빠르게 출시하기 위해 출시하는 것들로 위험을 감수하면서 모든 에러 버짓을 사용할 것이다. 이 기본 전제가 에러 버짓의 전체 모델을 설명한다. SRE 활동이 이 프레임워크에서 개념화되자마자, 단계적 롤아웃과 1% 실험 같은 전술을 통해 에러 버짓을 확보하면 더 빠른 출시를 최적화할 수 있다.

에러 버짓의 사용은 개발과 SRE 간의 인센티브의 구조적 갈등을 해결한다. SRE의 목표는 더 이상 "제로 장애"가 아니다; 오히려, SRE와 제품 개발자는 최대 기능 속도를 얻기 위해 에러 버짓을 사용하는 것을 목표로 한다. 이 변화가 모든 차이를 만든다. 장애는 더 이상 "나쁜" 것이 아니다—혁신 과정의 예상된 부분이며, 개발과 SRE 팀 모두가 두려워하기보다 관리하는 사건이다.

### 모니터링

모니터링은 서비스 소유자가 시스템의 건강과 가용성을 추적하는 주요 수단 중 하나다. 따라서 모니터링 전략은 신중하게 구성해야 한다. 모니터링에 대한 고전적이고 일반적인 접근 방식은 특정 값이나 조건을 관찰한 다음, 그 값이 초과되거나 그 조건이 발생하면 이메일 알림을 트리거하는 것이다. 그러나 이러한 유형의 이메일 알림은 효과적인 솔루션이 아니다: 사람이 이메일을 읽고 어떤 종류의 조치가 필요한지 결정해야 하는 시스템은 근본적으로 결함이 있다. 모니터링은 사람이 알림 도메인의 어떤 부분도 해석할 필요가 없어야 한다. 대신, 소프트웨어가 해석을 수행하고, 사람은 조치를 취해야 할 때만 알림을 받아야 한다.

세 가지 유효한 모니터링 출력 유형이 있다:

**알림(Alerts)**
: 현재 일어나고 있거나 곧 일어날 일에 대응해서 상황을 개선하기 위해 사람이 즉시 조치를 취해야 함을 의미한다.

**티켓(Tickets)**
: 사람이 조치를 취해야 하지만 즉시는 아님을 의미한다. 시스템이 상황을 자동으로 처리할 수 없지만, 사람이 며칠 내에 조치를 취하면 피해가 발생하지 않는다.

**로깅(Logging)**
: 아무도 이 정보를 볼 필요가 없지만, 진단 또는 포렌식 목적으로 기록된다. 다른 무언가가 프롬프트하지 않는 한 아무도 로그를 읽지 않을 것으로 예상된다.

### 긴급 대응

신뢰성은 평균 장애 시간(MTTF)과 평균 복구 시간(MTTR)의 함수다. 긴급 대응의 효과를 평가하는 데 가장 관련 있는 메트릭은 대응 팀이 시스템을 얼마나 빨리 건강하게 복원할 수 있는지—즉, MTTR이다.

사람은 지연을 추가한다. 주어진 시스템이 더 많은 *실제* 장애를 경험하더라도, 사람의 개입이 필요한 긴급 상황을 피할 수 있는 시스템은 직접 개입이 필요한 시스템보다 더 높은 가용성을 가진다. 사람이 필요할 때, "플레이북"에 모범 사례를 미리 생각하고 기록해두면 "즉석에서 해결하기" 전략에 비해 MTTR이 대략 3배 개선된다는 것을 발견했다. 만능 영웅 온콜 엔지니어가 작동하기는 하지만, 플레이북을 갖춘 훈련된 온콜 엔지니어가 훨씬 더 잘 작동한다. 아무리 포괄적이더라도 플레이북이 즉석에서 생각할 수 있는 똑똑한 엔지니어를 대체할 수는 없지만, 명확하고 철저한 문제 해결 단계와 팁은 고위험 또는 시간에 민감한 페이지에 대응할 때 가치가 있다. 따라서 구글 SRE는 온콜 플레이북과 함께 "Wheel of Misfortune"[^2]과 같은 훈련으로 엔지니어들이 온콜 이벤트에 대응할 준비를 한다.

### 변경 관리

SRE는 약 70%의 장애가 라이브 시스템의 변경으로 인해 발생한다는 것을 발견했다. 이 영역의 모범 사례는 자동화를 사용해서 다음을 수행한다:

- 점진적 롤아웃 구현
- 문제를 빠르고 정확하게 감지
- 문제가 발생하면 안전하게 변경 롤백

이 세 가지 관행의 조합은 나쁜 변경에 노출되는 사용자와 운영의 총 수를 효과적으로 최소화한다. 루프에서 사람을 제거함으로써, 이러한 관행은 피로, 익숙함/경시, 고도로 반복적인 작업에 대한 부주의의 일반적인 문제를 피한다. 결과적으로, 릴리스 속도와 안전 모두 증가한다.

### 수요 예측 및 용량 계획

수요 예측 및 용량 계획은 필요한 가용성으로 예상되는 미래 수요를 충족할 충분한 용량과 중복성이 있도록 보장하는 것으로 볼 수 있다. 이러한 개념에 특별한 것은 없지만, 놀랍도록 많은 서비스와 팀이 필요한 용량이 필요한 시점에 갖춰지도록 필요한 조치를 취하지 않는다. 용량 계획은 유기적 성장(고객의 자연스러운 제품 채택 및 사용에서 비롯됨)과 비유기적 성장(기능 출시, 마케팅 캠페인 또는 기타 비즈니스 주도 변경과 같은 이벤트에서 비롯됨) 모두를 고려해야 한다.

용량 계획에서 몇 가지 단계가 필수적이다:

- 용량 확보에 필요한 리드 타임을 초과하는 정확한 유기적 수요 예측
- 수요 예측에 비유기적 수요 소스의 정확한 통합
- 원시 용량(서버, 디스크 등)을 서비스 용량과 연관시키기 위한 시스템의 정기적인 부하 테스트

용량이 가용성에 중요하기 때문에, SRE 팀이 용량 계획을 담당해야 하며, 이는 프로비저닝도 담당해야 함을 의미한다.

### 프로비저닝

프로비저닝은 변경 관리와 용량 계획을 결합한다. 우리 경험상, 프로비저닝은 용량이 비싸기 때문에 신속하게 필요할 때만 수행해야 한다. 이 작업은 또한 올바르게 수행해야 하며 그렇지 않으면 필요할 때 용량이 작동하지 않는다. 새로운 용량을 추가하는 것은 종종 새로운 인스턴스나 위치를 시작하고, 기존 시스템(구성 파일, 로드 밸런서, 네트워킹)에 중대한 수정을 가하고, 새로운 용량이 성능을 발휘하고 올바른 결과를 제공하는지 검증하는 것을 포함한다. 따라서, 종종 시간당 여러 번 수행되는 로드 시프팅보다 더 위험한 작업이며, 그에 상응하는 정도의 추가 주의가 필요하다.

### 효율성과 성능

효율적인 자원 사용은 서비스가 비용에 관심이 있을 때마다 중요하다. SRE가 궁극적으로 프로비저닝을 제어하기 때문에, 활용도에 대한 모든 작업에도 참여해야 한다. 활용도는 주어진 서비스가 어떻게 작동하고 어떻게 프로비저닝되는지의 함수이기 때문이다. 따라서 서비스의 프로비저닝 전략, 따라서 활용도에 세심한 주의를 기울이면 서비스의 총 비용에 매우, 매우 큰 레버를 제공한다.

자원 사용은 수요(부하), 용량, 소프트웨어 효율성의 함수다. SRE는 수요를 예측하고, 용량을 프로비저닝하며, 소프트웨어를 수정할 수 있다. 이 세 가지 요소는 서비스 효율성의 큰 부분을(전부는 아니지만) 차지한다.

소프트웨어 시스템은 부하가 추가됨에 따라 느려진다. 서비스의 속도 저하는 용량 손실에 해당한다. 어느 시점에서 느려지는 시스템은 서비스를 중단하는데, 이는 무한한 느림에 해당한다. SRE는 *특정 응답 속도에서* 용량 목표를 충족하도록 프로비저닝하므로, 서비스의 성능에 깊은 관심을 가진다. SRE와 제품 개발자는 서비스를 모니터링하고 수정해서 성능을 개선하고, 따라서 용량을 추가하고 효율성을 개선할 것이다(그리고 그래야 한다).[^3]

## 시작의 끝

Site Reliability Engineering은 대규모의 복잡한 서비스를 관리하기 위한 기존 업계 모범 사례에서 상당한 단절을 나타낸다. 원래는 익숙함에서 동기부여를 받았다—"소프트웨어 엔지니어로서, 반복적인 작업 세트를 수행하기 위해 내 시간을 어떻게 투자하고 싶은가"—그것은 훨씬 더 많은 것이 되었다: 원칙의 집합, 관행의 집합, 인센티브의 집합, 더 큰 소프트웨어 엔지니어링 분야 내의 노력 분야. 이 책의 나머지 부분은 SRE Way를 상세히 탐구한다.

---

[^1]: 구글 엔지니어링 부사장, 구글 SRE 창립자

[^2]: 28장의 재해 역할극(Disaster Role Playing)을 참조하라.

[^3]: 이 협업이 실제로 어떻게 작동할 수 있는지에 대한 추가 논의는 31장의 커뮤니케이션: 프로덕션 미팅을 참조하라.

---

## 핵심 요약

- SRE는 소프트웨어 엔지니어에게 운영 팀을 설계하도록 요청하면 일어나는 일이다
- 구글은 SRE의 운영 작업에 50% 상한을 두어 나머지 시간에 엔지니어링에 집중할 수 있게 한다
- 에러 버짓은 개발과 운영 간의 구조적 갈등을 해결하는 핵심 개념이다
- 모니터링은 알림, 티켓, 로깅의 세 가지 유효한 출력으로 구성해야 한다
- 약 70%의 장애가 라이브 시스템의 변경으로 인해 발생한다
- 비난 없는 포스트모템 문화가 결함을 노출하고 수정하는 데 중요하다
