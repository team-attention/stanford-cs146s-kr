---
title: "좋은 컨텍스트가 좋은 코드를 만든다: AI 네이티브 엔지니어링 문화 구축기"
originalTitle: "Good Context Leads to Good Code: How We Built an AI-Native Eng Culture"
author: "Justin M Berman"
sourceUrl: "https://blog.stockapp.com/good-context-good-code/"
translatedAt: "2026-01-13"
status: "final"
---

# 좋은 컨텍스트가 좋은 코드를 만든다: AI 네이티브 엔지니어링 문화 구축기

[원본 링크](https://blog.stockapp.com/good-context-good-code/)

## TL;DR

StockApp을 만들면서 처음부터 AI 네이티브 개발 문화를 구축할 기회를 얻었습니다. 우리 경험상 이 방식은 수동 개발보다 약 2.5배 더 생산적이며, 기존 개발 문화에 AI를 추가하는 방식보다 약 2배 더 효율적입니다. AI 네이티브 개발은 엔지니어를 대체하는 게 아닙니다. 세심하게 설계한 공유 컨텍스트로 체계적인 인간-AI 협업을 만드는 것입니다. 이를 위해 몇 가지를 바꿨습니다:

* 모든 코드, 기술 문서, 에이전트 가이드라인을 모노레포에 정리하세요. 모노레포는 인간과 에이전트가 함께 쓰는 공유 작업 공간입니다. 에이전트와 함께 일하면 문서가 코드만큼 중요해집니다.
* 고수준 설계부터 시작해서 에이전트와 합의한 뒤, 점진적으로 코드 레벨까지 내려가세요.
* 가능한 모든 곳에서 에이전트를 최대한 자주 쓰되, 에이전트 작업을 감독하고 검토하며, 새로운 규칙을 지속적으로 가이드라인에 추가하세요.
* AI가 더 높은 품질과 확신을 갖고 작업할 수 있도록 환경에 MCP 서버와 명령줄 도구를 설정하세요. 이 설정을 팀원들과 공유하면 모두의 결과물 일관성과 품질이 향상됩니다.
* 여러 에이전트로 작업을 검토하고 사람이 검토하기 전에 승인받으세요. 인간과 멀티 에이전트 앙상블은 단일 에이전트나 에이전트만 쓰는 접근보다 일관되게 더 나은 성과를 냅니다.

## 상세 내용

StockApp은 2025년 1월에 시작했고, 처음부터 AI 네이티브 개발 중심으로 엔지니어링 문화를 구축할 독특한 기회가 있었습니다. 기존 프로세스에 AI 도구를 끼워 넣는 대신, 인간-AI 협업을 체계적으로 활용하도록 전체 개발 워크플로우를 설계했습니다.

개발자 생산성 측정이 어렵기로 악명 높지만, 객관적 측정¹이 뒷받침하는 우리의 주관적 경험은 약 2.5배의 생산성 향상을 가리킵니다—다른 곳에서 경험한 것보다 훨씬 높은 수치입니다. 우리 중 몇몇은 AI를 부분적으로 도입한 회사에서 일한 적 있는데, 그곳에서 AI로 인한 생산성 향상은 30~50% 범위였습니다. Google 같은 최상위 엔지니어링 조직 경험을 바탕으로 우리는 고성능 개발이 어떤 것인지 잘 알고 있으며, 이곳이 우리 누구도 경험하지 못한 가장 생산적인 환경입니다. 게다가 모델이 개선되면서(Claude 4.1의 코딩 성능 향상을 보세요) 인간과 에이전트가 더 긴밀하게 협업하는 법을 배우면서 생산성 향상은 계속 커지고 있습니다. 후자가 중요합니다: 우리는 함께 일하는 방법을 많이 실험하고 반복합니다. 같은 모델을 쓰더라도 아래와 같은 더 나은 기법들이 생산성을 측정 가능하게 향상시켰습니다.

우리의 핵심 통찰: **좋은 코드는 좋은 컨텍스트의 부산물입니다.** 새로운 AI 네이티브 개발 프로세스는 인간과 에이전트가 함께 컨텍스트를 점진적으로 구축하고 공유하는 것입니다. 이게 효과적으로 이뤄지면, 우수한 소프트웨어 산출물이 자연스럽게 나옵니다.

우리의 개발 프로세스가 다른 분들에게도 유용하길 바라며 공유합니다.

한 가지 강조할 점은 이 접근 방식이 소프트웨어 엔지니어링 전문성을 더 적게가 아니라 _더 많이_ 요구한다는 것입니다. 컨텍스트를 효과적으로 정의하는 건 좋은 코드를 작성하는 것만큼 기술적으로 도전적입니다: 가장 중요한 정보가 무엇인지, 에이전트가 그걸 어떻게 해석할지 신중하게 고려해야 합니다—모든 게 머릿속에 있을 때는 걱정할 필요 없는 두 가지입니다. 더구나 에이전트가 실수하면 영향 범위가 클 수 있습니다(예를 들어, 오작동하는 에이전트가 우리 개발 데이터베이스를 몇 번 날려버린 적 있습니다). 에이전트를 쓸 때 우리는 보통 완전히 집중합니다. 현재 개발 수준의 에이전트는 분명히 잘못된 방향으로 이끌 수 있어서, 그걸 막으려면 경계심 있고, 주의 깊고, 경험 있는 눈이 필요합니다.

## 기본 개발 환경

우리의 기술적 결정을 맥락에 맞게 이해하려면 개발 환경의 핵심 요소를 설명하는 게 도움이 됩니다. 웹 프론트엔드는 TypeScript로 작성했고, 백엔드 서비스는 Python과 TypeScript로 나눠서 모두 단일 모노레포에서 관리합니다. 일상적인 코딩 지원에 Claude Code를 쓰며, 대부분의 팀원이 실시간 자동완성을 위해 Cursor 안에서 실행합니다; Cursor의 자체 내장 AI는 거의 안 씁니다. VS Code, Windsurf, Gemini CLI도 시도해봤지만, 이 구성이 우리 워크플로우에 가장 효과적이었습니다.

## 우리가 배운 다섯 가지 원칙

다섯 가지 원칙 모두 하나의 아이디어에서 비롯됩니다: 인간과 에이전트가 공유 컨텍스트를 반복적으로 생성하고, 개선하고, 소비해야 합니다. 이게 일어나면 훌륭한 소프트웨어가 만들어지고, 코드 자체는 중간 산출물이 됩니다; 어셈블리가 고수준 언어와 기계어 사이에 위치하는 것처럼요.

### 저장소는 인간과 에이전트의 공유 작업 공간이다

AI 성능이 접근 가능한 컨텍스트에 크게 의존하기 때문에 우리 저장소는 기계뿐 아니라 인간을 위해서도 조직합니다. 프롬프트 엔지니어링보다 컨텍스트 엔지니어링이 이제 더 중요한 이유입니다. 모노레포가 우리 운영 프로세스의 중요한 부분인 이유이기도 합니다.

자연어는 프로그래밍 언어만큼 중요하므로, 영어 산문을 TypeScript나 Python에 주는 것과 같은 주의를 기울입니다.

이를 위해 시스템 상태가 인간과 에이전트 모두에게 보여야 합니다. 우리는 의도적으로 인간만으로 구성된 팀보다 더 많은 걸 저장소에 넣습니다. 우리 저장소는 인간만을 위한 게 아니라 기계를 위한 것이기도 하니까요.

우리의 문서 중심 접근 방식은 자연어 산출물을 일급 시민으로 취급합니다. 핵심 컨텍스트는 다음에 저장합니다:

* **docs/designs/**: 제품 요구사항, 고수준 목표, 스키마. "왜"와 "무엇"입니다.
* **docs/plans/**: 상세하고 단계적인 구현 계획, 종종 인간과 에이전트가 공동으로 생성합니다. "어떻게"입니다.
* **docs/guides/**: API와 도구 튜토리얼, 종종 에이전트가 관련 문서를 읽은 후 초안을 작성합니다.
* **schema.sql**: 전체 프로젝트를 위한 단일 표준 스키마로, 데이터 구조의 단일 진실 공급원입니다.
* **README.md & CLAUDE.md**: 저장소 전체에 배치하여, 코드베이스의 특정 부분에서 작업하는 인간과 에이전트 모두에게 지역화된 지침을 제공합니다.

### 계층적 개발로 컨텍스트를 점진적으로 구축한다

더 나은 컨텍스트는 더 나은 코드로 이어지지만, 컨텍스트를 만드는 건 간단하지 않습니다. 우리는 하향식으로 작업하며, 인간과 에이전트가 각 수준에서 협업합니다:

1. **설계** – 인간이 핵심 요구사항과 제약조건을 제공합니다; 에이전트가 설계 문서 초안을 작성합니다; 둘이 반복하고 커밋합니다.
2. **계획** – 에이전트가 설계를 단계별 태스크로 변환합니다; 인간이 검토하고 승인합니다.
3. **구현** – 에이전트가 대부분의 코딩을 처리합니다; 인간이 결과를 검토합니다.
4. **안전장치** – 테스트와 기타 보호장치가 나중 변경으로 힘들게 구축한 컨텍스트가 훼손되지 않도록 보장합니다. 가장 명백한 안전장치는 테스트지만, 더 넓게는 우리가 구축한 컨텍스트를 강제하는 모든 메커니즘을 포함합니다.
5. **리뷰** – 인간과 에이전트가 기능의 최종 리뷰를 수행하며, 원래 설계 문서에 명시한 목표를 충족하는지 확인합니다.
6. **업데이트 및 개선** – 문서, CLAUDE.md 파일, 스키마를 업데이트하여 미래의 에이전트가 정확한 컨텍스트를 상속받도록 합니다.

### 좋은 이유가 없는 한 _모든 것_에 에이전트를 사용하라

우리는 거의 모든 작업에 에이전트를 쓰며, 어떤 작업을 시작하기 전에 AI로 할 수 있는지 먼저 묻습니다. 위에서 언급했듯이, 에이전트가 감독 없이 운전대를 잡게 하는 경우는 거의—아니, 전혀—없습니다. 엔터를 누르기 전에 에이전트가 하는 것과 추천하는 걸 꼼꼼히 확인합니다. 우리는 "바이브 코딩"을 하지 않습니다. 이 감독과 확인에는 여전히 우리의 가장 깊은 기술적 전문성이 필요합니다.

에이전트를 쓰는 몇 가지 비전통적인 방법을 나열합니다:

* 에이전트는 아이디어를 검토하는 훌륭한 상대이며, 작업에 쓸 수 있는 라이브러리를 조사하는 것 같은 연구의 단조로운 측면을 도울 수 있습니다.
* 에이전트가 대부분의 커밋과 PR 메시지를 작성합니다.
* 충분한 컨텍스트가 있으면 문서를 직접 편집하는 대신 에이전트에게 문서 업데이트를 지시합니다. 예를 들어, 에이전트와 인간이 함께 구축한 주요 코드 변경 후에는 README 파일을 업데이트하기에 충분한 정보가 있으며, 설계에 변경이 있었다면 설계 문서도 업데이트합니다.
* CLAUDE.md 파일을 직접 편집하는 대신 에이전트에게 업데이트를 지시합니다. 에이전트는 우리보다 자신에게 지시하는 방법을 더 잘 압니다.
* 우리는 프롬프트를 직접 쓰지 않습니다. 컨텍스트와 우리의 "메타 프롬프트"를 고려해서 에이전트에게 프롬프트를 작성해달라고 요청합니다.
* 에이전트가 테스트를 작성하지만, 에이전트가 테스트를 "과도하게 모킹"하는 경향이 있어 주의합니다. 더 중요한 건, 변경 후에 에이전트에게 테스트 업데이트를 요청한다는 것입니다. 테스트는 AI 네이티브 코드베이스에서 더 중요한 역할을 합니다. 왜냐하면 중요한 안전장치이기 때문입니다. 에이전트는 말 그대로 컨텍스트 윈도우 측면에서 제한된 컨텍스트를 가지므로, 에이전트가 전역적으로 뭔가를 깨뜨리면서 문제를 지역적으로 해결하는 경향이 높습니다. 광범위한 테스트가 이 문제를 줄이는 데 도움이 됐습니다.
* 디버깅은 인간과 에이전트의 공동 활동입니다. 보통 인간이 근본 원인에 대한 가설을 세우고, 에이전트에게 검증을 요청합니다. 에이전트는 가설을 스스로 세우는 것보다 가설을 검증하는 데 훨씬 더 능숙해 보입니다. 또한, 에이전트는 인간이 하기엔 너무 지루한 계측 작업에 뛰어납니다. 우리가 배운 가장 큰 교훈 중 하나는 복잡한 크로스 라이브러리 문제를 디버깅하는 데 AI가 얼마나 효율적인지입니다. LLM과 프론트엔드 사이에 정보가 네 개의 라이브러리를 통과해야 하는 까다로운 버그가 있었습니다. AI에게 모든 라이브러리(Python 라이브러리 디렉토리에 직접)에 디버그 문을 삽입하고, 로그를 분석하고, 어떤 라이브러리에 버그가 있는지 판단하도록 요청했습니다.
* 에이전트에게 코드 개선점을 찾도록 지시합니다. 예를 들어, 중복 코드, 죽은 코드, 보안 이슈, 개인정보 이슈 등을 찾습니다. 그런 다음 에이전트에게 수정을 요청합니다.
* 충돌이 있을 때 수동 병합을 거의 안 합니다. 대부분의 경우 병합은 상대적으로 간단하며, 복잡한 경우엔 에이전트가 충분히 똑똑해서 멈추고 안내를 요청합니다.

개발의 모든 단계에서 우리는 기본적으로 에이전트를 써서 가능한 한 많이 하려고 합니다. 이 수준의 에이전트 자율성은 마법이 아닙니다; 공유 컨텍스트를 생성하고 유지하기 위한 체계적인 투자의 직접적인 결과입니다. 설계 문서와 계획 덕분에 AI는 훌륭한 커밋 메시지를 작성하고 인간보다 더 나은 프롬프트를 작성할 수 있습니다.

### MCP와 명령어로 컨텍스트 이해와 확장을 더 쉽게 한다

우리는 시스템에서 MCP(Model Context Protocol) 서버를 광범위하게 씁니다. 또한 AI가 스스로 정보를 탐색할 수 있도록 강력한 명령줄 옵션 접근 권한을 제공합니다. 새 저장소를 설정할 때 쓰는 MCP 서버를 설치하는 install_mcp.sh라는 스크립트가 있습니다. 현재 약 6개의 MCP 서버를 설치합니다. 여기엔 다음이 포함됩니다:

* **Notion과 Linear**: 이로 의사결정을 위한 더 많은 컨텍스트를 얻을 수 있습니다(예: Linear에서 기능 설명 읽기). 정보 업데이트에도 씁니다. 예를 들어 "우리가 작업한 이슈가 수정됐다고 보고해줘"라고 말하면 Linear를 업데이트합니다. 새 이슈 만들기에도 매우 편리합니다 – Notion의 고수준 설계와 Linear의 이슈 사이를 연결하는 다리로 쓸 수 있습니다. "이 페이지의 태스크 목록을 가져와서 Linear에 추가해줘" 같은 명령으로요.
* **AWS와 SQL 개발 데이터베이스**: 에이전트가 이제 디버깅에 필요한 정보를 얻기 위해 이런 정보 소스를 직접 읽을 수 있습니다. 예를 들어, 분석을 위해 AWS에서 서버 로그를 가져오고, 개발 데이터베이스에 저장된 정보가 올바른지 확인할 수 있습니다.
* **Git과 GitHub 명령어**: 이전 버전의 코드를 조사하고, 제출된 모든 커밋을 살펴보며 컨텍스트를 파악하고, PR을 생성하고, 저장소 문제를 해결합니다. 에이전트는 아마 대부분의 엔지니어보다 Git을 더 잘 다룰 겁니다.

가장 흥미로운 점은 MCP 서버가 다른 방법으론 연결하기 어려운 "격차를 연결"하는 걸 얼마나 쉽게 만드는지입니다. 예를 들어, "Linear에서 버그 설명을 읽고, 최근 10개 커밋을 살펴봐서 어떤 게 버그를 일으켰을 가능성이 가장 높은지 찾아줘"라고 말할 수 있습니다.

### 앙상블이 개인보다 뛰어나다

전통적인 머신러닝이 가르쳐주는 교훈이 있다면, 앙상블이 개인보다 뛰어나다는 것입니다. 랜덤 포레스트, 스태킹, 배깅, 부스팅 같은 다양한 기법이 있습니다. 이 모든 기법에서 둘 이상의 분류기를 구축한 다음 그들 사이에 일종의 투표 메커니즘을 씁니다. 분류기에 충분한 다양성이 있는 한, 어떤 개인보다 앙상블에서 상당히 더 나은 결과를 볼 가능성이 높습니다.

아마 우리가 가진 가장 흥미로운 MCP 서버는 Zen MCP 서버입니다. 이로 Claude Code는 Gemini나 o3 같은 다른 LLM에게도 피드백을 요청할 수 있습니다. 우리는 이걸 시스템 성능을 향상시키는 데 썼으며, 다른 LLM들이 각각의 강점과 약점이 있다는 걸 발견했습니다. 이걸 위의 개발 프로세스와 결합해서 씁니다. 예를 들어, Claude Code가 설계를 마치면 Gemini에게도 검토를 받습니다. 이런 다양성은 여러 면에서 도움이 됩니다. 예를 들어, Gemini는 보안 이슈를 선제적으로 식별하는 데 훨씬 더 나은 결과를 보여줬습니다. MCP 서버 인증을 어떻게 구현할지 고민하던 최근 사례가 있는데, o3와 Gemini의 의견이 달랐습니다.

Gemini의 관점: 페이로드 기반 인증을 기본 선택으로 강력히 권장하며, "가장 실용적이고 확장 가능한 솔루션"이자 "성능, 확장성, 유지보수성 사이에서 최상의 균형을 이루는" 방식이라고 평가합니다.

o3의 관점: 더 신중한 입장으로, 보안 문제와 LLM 간섭을 이유로 프로덕션 시스템에선 사용자별 클라이언트를 1순위로 평가합니다. 페이로드 기반 인증을 2순위로 평가하지만 토큰 유출 위험과 복잡성에 대해 경고합니다.

궁극적으로 인간과 에이전트가 앙상블을 형성합니다. 이 앙상블이 어떤 개별 구성원보다 더 나은 성과를 낼 수 있게 하는 다리가 바로 공유 컨텍스트입니다. 컨텍스트에 투자하는 게 AI 네이티브 시스템을 구축하는 데 가장 중요한 부분인 이유입니다.

_우리는 AI 네이티브 개발의 경계를 넓히고 AI와 커머스의 교차점에서 훌륭한 제품을 만들 뛰어난 엔지니어를 찾고 있습니다. 혁신적인 기술을 만들면서 소프트웨어가 어떻게 구축되는지의 미래를 정의하고 싶다면, careers@stockapp.com으로 연락주세요._

## 각주

¹ **개발 지표 (2025년 2분기)**: 개발자 생산성 지표는 신중하게 해석해야 하지만, 우리의 객관적 측정엔 다음이 포함됩니다: 13주 동안 1,098개의 PR 전달(주당 84.5개 PR), 개발자당 주 10.6개 PR 대 업계 표준 ~1 PR/개발자/주(LinearB 2025). 하지만 우리는 프로젝트의 "빌드" 단계에 있으며, 보통 가장 빠른 단계입니다. 업계 표준 "빌드 + 유지보수" 평균과 비교해야 합니다.

---

## 핵심 요약

- 좋은 코드는 좋은 컨텍스트의 부산물이다
- 모노레포를 인간과 에이전트의 공유 작업 공간으로 활용하라
- 고수준 설계부터 시작해 점진적으로 코드 레벨로 내려가라
- 가능한 모든 곳에서 에이전트를 쓰되, 항상 감독하라
- MCP 서버로 에이전트에게 더 많은 컨텍스트를 제공하라
- 여러 AI 모델을 앙상블로 써서 품질을 높여라
