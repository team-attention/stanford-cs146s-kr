---
title: "Warp로 코드베이스 이해하기"
originalTitle: "Understanding your Codebase with Warp"
category: "how-warp-uses-warp"
sourceUrl: "https://www.youtube.com/watch?v=pohnoRZas-E"
translatedAt: "2026-01-20"
status: "draft"
---

# Warp로 코드베이스 이해하기

[영상 바로가기](https://www.youtube.com/watch?v=pohnoRZas-E)

## 핵심 요약

- Warp의 Context 기능은 코드베이스를 의미론적으로 검색하고 이해할 수 있게 해줍니다
- 단일 IDE 프로젝트에 제한되지 않고 여러 코드베이스(예: Rust 클라이언트 + Go 서버)를 동시에 검색 가능
- 의미론적 검색 덕분에 정확한 함수명이나 변수명을 몰라도 관련 코드를 찾을 수 있음
- 저장된 프롬프트(Warp Drive 워크플로우)를 재사용하여 엔드투엔드 기능 설명 요청 가능
- 파일 변경 시 실시간 증분 동기화로 항상 최신 코드 참조
- 새로운 기능이나 익숙하지 않은 코드 영역의 온보딩 시간 대폭 단축

---

## 전체 번역

안녕하세요, Kevin입니다. Warp에서 소프트웨어 엔지니어로 일하고 있습니다.

>> 안녕하세요, Lucy입니다. 저도 Warp의 소프트웨어 엔지니어입니다.

>> 오늘은 Warp에서 구축 중인 새로운 기능인 Context를 소개하려고 합니다. 이 기능은 Warp가 코드베이스를 이해하고 의미론적으로 검색할 수 있는 능력을 제공합니다.

>> Lucy와 Kevin, 테이크 원. 시작. >> 저는 한동안 Windows용 Warp 빌드와 Linux용 Warp 빌드 작업을 했습니다. 이제는 블록 공유(block sharing)라는 기능을 작업하고 싶습니다. 이 기능은 Warp에 이미 존재하지만 개선하고 싶은 부분이 있습니다. 문제는 제가 플랫폼 관련 작업을 해왔기 때문에 블록 공유가 어떻게 작동하는지 잘 모른다는 것입니다. 이 기능은 두 개의 코드베이스를 사용합니다. Rust로 작성된 클라이언트 코드베이스와 Go로 작성된 서버 코드베이스를 봐야 합니다. 따라서 코드베이스 컨텍스트가 엔드투엔드로 기능을 이해하는 데 도움이 될 수 있는지 확인할 좋은 기회입니다.

>> 네, 저는 이전에 이 코드베이스 부분을 작업한 적이 있습니다. 일반적으로는 일대일 온보딩을 하고 흐름의 모든 부분을 설명해야 하지만, 오늘은 Warp가 온보딩을 어떻게 도와주는지 확인해 보겠습니다.

>> 그럼 Warp로 가서 Warp Drive를 열겠습니다. 여기에 "Warp 기능을 엔드투엔드로 설명"하는 공유 워크플로우가 있습니다. 이건 정말 편리합니다. 저장된 프롬프트로, LLM을 위한 Warp 프롬프트를 재사용할 수 있게 해줍니다. 이 경우 클라이언트 코드를 위해 warp internal을, 서버 코드를 위해 warp internal을 보도록 Warp에 지시하고 있으며, 특정 기능을 설명해 달라고 요청할 것입니다. 그럼 블록 공유를 입력하고 Warp가 무엇을 제시하는지 봅시다.

>> Warp의 코드베이스 컨텍스트 구축 방식의 핵심은 단일 코드베이스에 국한되지 않는다는 것입니다.

IDE에서 동일한 기능을 구축한다고 생각하면, 자연스럽게 범위가 작업 중인 프로젝트의 현재 에디터로 제한됩니다. 하지만 우리는 여러 코드베이스에서 편집이 필요한 엔드투엔드 워크플로우가 많다는 것을 인식했습니다.

>> 이 경우 사용자가 실제로 블록을 공유하는 클라이언트 코드베이스에서 일부 결과를 볼 것으로 예상합니다. 또한 공유된 블록을 보려는 사용자에게 페이지나 위젯을 제공할 서버 코드베이스에서도 결과를 볼 것으로 예상합니다.

>> 네. 지금 보시는 것처럼 정확히 우리의 지시를 따르고 있습니다. 클라이언트 코드베이스에서 블록 공유를 검색하고 있습니다. 렌더링하는 위치에서 올바른 파일을 찾고 있습니다. 이제 서버 코드베이스에서 GraphQL로 어떻게 처리하는지 찾고 있습니다.

정말 멋지네요. 흥미로운 점은 의미론적 검색(semantic search) 덕분에 Warp가 특정 함수명이나 변수명, 코드베이스의 용어를 제공하지 않아도 이 기능이 어떻게 작동하는지 찾을 수 있다는 것입니다. 여기에는 제가 스스로 찾아볼 생각을 하지 못했을 파일과 함수들이 있습니다. 하지만 의미론적 검색 덕분에 정확한 검색어를 알 필요가 없습니다.

>> 좋아요. 결과를 찾은 것 같고 요약을 제공하고 있습니다.

어떻게 했는지 봅시다.

Warp는 클라이언트 측 아키텍처 개요를 제공하는 것으로 시작했습니다. share block 모델에서 어떻게 렌더링하는지 설명했습니다. 정확히 맞습니다. 제목 생성 방법을 보여주는 옵션도 제공하고, 디스플레이를 위한 다양한 설정도 있습니다. 이제 GraphQL 클라이언트 통합으로 가고 있습니다. 제게는 정확히 맞는 것 같습니다. 모든 링크가 작동해서 해당 파일로 바로 이동할 수 있도록 잘 포맷되어 있는 것도 좋습니다. 우리가 조금 다르게 하는 것은, 인덱싱된 코드베이스의 파일을 변경하면 Warp가 파일이 변경되었음을 감지하고 서버에 그 변경사항을 증분 동기화합니다. 변경된 특정 파일에 대한 새로운 임베딩을 생성하고 비교적 빠르게 해당 임베딩을 업데이트합니다. 따라서 Warp에게 코드를 작성하도록 요청했는데 Warp가 오래된 파일이나 이미 변경한 파일을 참조하는 상황은 발생하지 않습니다. 업데이트가 즉시 발생합니다. 이것은 단순히 코드로 시작하는 것보다 훨씬 더 유용한 출발점입니다. 그리고 이것은 Kevin의 온보딩 시간도 엄청나게 절약해 줍니다.

>> 네, 맞습니다. 이 전체 요약에 대해 어떻게 생각하세요?

>> 훨씬 낫습니다. 이걸로 작업할 수 있을 것 같아요.

>> 좋아요.